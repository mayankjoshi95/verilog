##general procedure for verilog
module ();
logic
endmodule
reg data type cannot be used in the dut or uut .
operators in verilog 
~ is the negation is the unary operator
& to perform and operation binary opreerator
(a==b)?(b:c);
to declare soome undefined net there we prefer the wire .
#to define a temporary variable we start with the 'reg a'it will create a single bit reg variable and a multi bit reg variable i.e a single flip flop or a multi bit flip lflop
#integer a;
#time 
#real a=2.3
reg[4:0] a=1010 #by default we have a deecimal number and here we are taking the binary values as decimal 

##so foramt is 
// size ,base we are planning to feed the number in 'b'#binary format  'h'#hexa format 
#reg[4:0] a =5'b01010;#here data we are feeding is 5 bit it is in binary format it is 10100
##size is 5 since our variable is of 5 then hexa or decimal then put the values
5 is the size .

#assignment operator
LHS side we have input port and RHS side output port 
#how you assign value to an output port 


1.contiinuos assignment :-as soon as any value on HRS change your LHS will be updated and to specify continuos assignment we use assign keyword.
#for combinational circuit
2.procedural assignment :-it wait for an event to happen and once tht event happen value of an RHS will be changing and then LH changes i.e we will not see any change in input and output 
until we receive any change in clock.
##further to two classes it can either be blocking or it can be non blocking .
##sequential circuit

#continuos assignment 

module tb();
reg a=1;
reg b=1;
reg c//with reg data type the suitable assignment which is allowed is the wire data type
c=a&b;
endmodule
#use of initial constructs to initialized reg variable 

#use of intial is to genrate an arrbitrary random stimuli

module tb();
reg a=1;
reg b=1;
wire  c//with reg data type the suitable assignment which is allowed is the wire data type
assign c=a&b;
endmodule


#in procedural assignmetn we us e the reg data type 
module tb();
reg a=1;
reg b=1;
reg  c;
always@(a)//with reg data type the suitable assignment which is allowed is the wire data type
begin
 c=a&b;##there is no assign before c.
end 
endmodule

always #50  a=~a;
always #20 b=~b;



##BLOCKING ASSIGNMENT 

c=a&b;
#20;
d=a|b;
#20

e=a&b;
end 
endmodule
#thus in case of blocking operator we operate sequentially 
#non blocking 

c=a&b;
#20;
d=a|b;
#20

e=a&b;
end 
endmodule

##here they operate in a parallel manner 

use output with reg datatype .

##test bench 


module tb();
reg a=0;
initial begin 
a=0;
end 
always #5 a=~a;##thsi is  ahalf clock period .
initial begin
#1000;
$finish;##this will forcefully stop our simulator
end 
endmodule
initial begin 
##so whenever you are required to generate an arbitrary wave signal initial bbegin is very important .
##or t create a random signal which are multi bit there also intial begin is very very useful
##to have the value of the variable in the console which help in the debugging scenario 

##whereever you have a situtation where you wwnat to print the value at a specific line there display is qquite usefull
##monitor is used to display the values of the variable as soon as it changes its value 





module tb();
reg a;
initial begin
a=0;
#10;
a=1;
$display("value of a with display:0%b",a);
#20;
a=0;
#10;
a=1;
#20;

end
initial begin//to add the monitor we simly use initial begin 
$monitor("value of a with monitor:0%b",a);///monitor will print four values of a diplay will print value of a at that line
end 
endmodule
value of a with monitor:00
value of a with display:01
value of a with monitor:01
value of a with monitor:00
value of a with monitor:01

##in the tcl console we have the value of the monitor

##use of task in the bench 

##task can also operate on reg data type which we have declared outside the task.




#hw to connect the design under test and DUT
MODULE TOP(
INPUT [3:0] DIN,
OUTPUT [3:0] DOUT);
ASSIGN DOUT=DIN;
ENDMODILE


module tb();
reg[3:0] din;
wire [3:0] dout ;##it should not be intialized
initial begin#intialize all the reg data type
din=0;
end
top uut(din,dout);#imlicit
top uut(.din(din),.dout(dout))


##use of struuctural modelling style 

module ha(input a,b,
output s,c);
assign s=a^b;
assign c=a&b;


module fa (input a,b,cin,
   output sout,cout);
   
wire t1,t2,t3;
ha h1(a,b,t1,t2)
ha h2(.s(sout),.c(t3),.a(cin),.b(t1))
assign cout= t3|t2;

   
endmodule   


##constraints consitss of mapping of our io port to fpga io ports .


















































