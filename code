##general procedure for verilog
module ();
logic
endmodule
reg data type cannot be used in the dut or uut .
operators in verilog 
~ is the negation is the unary operator
& to perform and operation binary opreerator
(a==b)?(b:c);
to declare soome undefined net there we prefer the wire .
#to define a temporary variable we start with the 'reg a'it will create a single bit reg variable and a multi bit reg variable i.e a single flip flop or a multi bit flip lflop
#integer a;
#time 
#real a=2.3
reg[4:0] a=1010 #by default we have a deecimal number and here we are taking the binary values as decimal 

##so foramt is 
// size ,base we are planning to feed the number in 'b'#binary format  'h'#hexa format 
#reg[4:0] a =5'b01010;#here data we are feeding is 5 bit it is in binary format it is 10100
##size is 5 since our variable is of 5 then hexa or decimal then put the values
5 is the size .

#assignment operator
LHS side we have input port and RHS side output port 
#how you assign value to an output port 


1.contiinuos assignment :-as soon as any value on HRS change your LHS will be updated and to specify continuos assignment we use assign keyword.
#for combinational circuit
2.procedural assignment :-it wait for an event to happen and once tht event happen value of an RHS will be changing and then LH changes i.e we will not see any change in input and output 
until we receive any change in clock.
##further to two classes it can either be blocking or it can be non blocking .
##sequential circuit

#continuos assignment 

module tb();
reg a=1;
reg b=1;
reg c//with reg data type the suitable assignment which is allowed is the wire data type
c=a&b;
endmodule
#use of initial constructs to initialized reg variable 

#use of intial is to genrate an arrbitrary random stimuli

module tb();
reg a=1;
reg b=1;
wire  c//with reg data type the suitable assignment which is allowed is the wire data type
assign c=a&b;
endmodule


#in procedural assignmetn we us e the reg data type 
module tb();
reg a=1;
reg b=1;
reg  c;
always@(a)//with reg data type the suitable assignment which is allowed is the wire data type
begin
 c=a&b;##there is no assign before c.
end 
endmodule

always #50  a=~a;
always #20 b=~b;



##BLOCKING ASSIGNMENT 

c=a&b;
#20;
d=a|b;
#20

e=a&b;
end 
endmodule
#thus in case of blocking operator we operate sequentially 
#non blocking 

c=a&b;
#20;
d=a|b;
#20

e=a&b;
end 
endmodule

##here they operate in a parallel manner 

use output with reg datatype .

##test bench 

module tb();
reg a=0;
initial begin 
a=0;
end 
always #5 a=~a;
initial begin
#1000;
$finish;
end 
endmodule



#hw to connect the design under test and DUT
MODULE TOP(
INPUT [3:0] DIN,
OUTPUT [3:0] DOUT);
ASSIGN DOUT=DIN;
ENDMODILE


module tb();
reg[3:0] din;
wire [3:0] dout ;##it should not be intialized
initial begin#intialize all the reg data type
din=0;
end
top uut(din,dout);#imlicit
top uut(.din(din),.dout(dout))


##use of struuctural modelling style 

module ha(input a,b,
output s,c);
assign s=a^b;
assign c=a&b;


module fa (input a,b,cin,
   output sout,cout);
   
wire t1,t2,t3;
ha h1(a,b,t1,t2)
ha h2(.s(sout),.c(t3),.a(cin),.b(t1))
assign cout= t3|t2;

   
endmodule   


##constraints consitss of mapping of our io port to fpga io ports .


















































